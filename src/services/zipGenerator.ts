import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { SelectedImage, ProjectInfo, ImageType } from '@/types';
import imageCompression from 'browser-image-compression';
import { CompressionSettings } from '@/components/ui/compression-options';

// Define a type for edited images
export interface ImageToDownload {
  type: ImageType;
  src: string;
  isEdited: boolean;
}

// Helper function to fetch an image from URL and convert to blob
async function fetchImageAsBlob(url: string): Promise<Blob> {
  if (url.startsWith('data:')) {
    // Handle data URLs (for edited images)
    const response = await fetch(url);
    return response.blob();
  }
  
  // Handle regular URLs
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch image: ${response.statusText}`);
  }
  return response.blob();
}

// Helper function to compress an image
async function compressImage(
  imageBlob: Blob, 
  options: CompressionSettings
): Promise<Blob> {
  if (!options.enabled) {
    return imageBlob;
  }

  // Create compression options
  const compressionOptions = {
    maxSizeMB: options.maxSizeMB,
    maxWidthOrHeight: options.maxWidthOrHeight,
    useWebWorker: true,
    preserveExif: options.preserveExif,
    initialQuality: options.quality,
  };

  try {
    // Create a File object from the Blob for the compression library
    const imageFile = new File([imageBlob], 'image.jpg', { 
      type: imageBlob.type || 'image/jpeg' 
    });
    
    return await imageCompression(imageFile, compressionOptions);
  } catch (error) {
    console.error('Error compressing image:', error);
    // If compression fails, return the original blob
    return imageBlob;
  }
}

export async function generateZip(
  selectedImages: ImageToDownload[] | SelectedImage[], 
  projectInfo: ProjectInfo,
  compressionOptions?: CompressionSettings
): Promise<void> {
  const zip = new JSZip();
  const folder = zip.folder(`${projectInfo.businessType}-stock-images`);
  
  if (!folder) {
    throw new Error('Failed to create folder in zip file');
  }
  
  try {
    // Create a README.txt file with information about the images
    folder.file('README.txt', 
      `Stock Images for ${projectInfo.businessType} project
Generated by PolarStock
Date: ${new Date().toLocaleString()}
Description: ${projectInfo.description}

Images included:
${selectedImages.map((img, i) => 
  `${i+1}. ${img.type}.jpg`
).join('\n')}

These images are free to use for personal and commercial projects.
Please check individual image sources for specific license details.`
    );
    
    // Add each image to the zip file
    await Promise.all(selectedImages.map(async (selectedImg, index) => {
      try {
        // Determine if we're working with an ImageToDownload or SelectedImage
        const isImageToDownload = 'isEdited' in selectedImg;
        
        // Get the image URL
        let imageUrl: string;
        
        if (isImageToDownload) {
          // For edited images, use the src directly
          const img = selectedImg as ImageToDownload;
          imageUrl = img.src;
        } else {
          // For original images, get the URL from image properties
          const img = selectedImg as SelectedImage;
          // Only proceed if image exists
          if (!img.image) {
            throw new Error(`No image found for ${img.type}`);
          }
          
          imageUrl = img.image.src.large2x || 
                     img.image.src.large || 
                     img.image.src.original || 
                     img.image.src.medium;
        }
        
        // Fetch the image as a blob
        let imageBlob = await fetchImageAsBlob(imageUrl);
        
        // Compress the image if compression options are provided and it's not edited
        // (Edited images are already optimized)
        if (compressionOptions && !(isImageToDownload && (selectedImg as ImageToDownload).isEdited)) {
          imageBlob = await compressImage(imageBlob, compressionOptions);
        }
        
        // Create a filename (use image type as name)
        const fileName = `${selectedImg.type}.jpg`;
        
        // Add the image to the zip file
        folder.file(fileName, imageBlob, { binary: true });
      } catch (error) {
        console.error(`Error adding image ${selectedImg.type} to zip:`, error);
        throw error;
      }
    }));
    
    // Generate the zip file
    const content = await zip.generateAsync({ type: 'blob' });
    
    // Trigger download with a descriptive filename
    saveAs(content, `${projectInfo.businessType}-stock-images.zip`);
  } catch (error) {
    console.error('Failed to generate zip file:', error);
    throw error;
  }
} 